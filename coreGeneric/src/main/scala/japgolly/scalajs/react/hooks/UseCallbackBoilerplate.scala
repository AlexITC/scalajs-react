package japgolly.scalajs.react.hooks

// DO NOT MANUALLY EDIT
// DO NOT MANUALLY EDIT
//
// THIS IS GENERATED BY RUNNING genHooks IN SBT
//
// DO NOT MANUALLY EDIT
// DO NOT MANUALLY EDIT

import japgolly.scalajs.react.Reusable
import japgolly.scalajs.react.hooks.Hooks.UseCallbackArg
import japgolly.scalajs.react.util.Effect._
import scala.scalajs.js

trait UseCallbackArgInstances {

  implicit def c1[A, Z[_]](implicit Z: Dispatch[Z]): UseCallbackArg[(A) => Z[Unit]] =
    UseCallbackArg[(A) => Z[Unit], js.Function1[A, Unit]](
      z => (a) => Z.dispatch(z(a)))(
      z => Reusable.byRef(z).withValue((a) => Z.delay(z(a))))

  implicit def c2[A, B, Z[_]](implicit Z: Dispatch[Z]): UseCallbackArg[(A, B) => Z[Unit]] =
    UseCallbackArg[(A, B) => Z[Unit], js.Function2[A, B, Unit]](
      z => (a, b) => Z.dispatch(z(a, b)))(
      z => Reusable.byRef(z).withValue((a, b) => Z.delay(z(a, b))))

  implicit def c3[A, B, C, Z[_]](implicit Z: Dispatch[Z]): UseCallbackArg[(A, B, C) => Z[Unit]] =
    UseCallbackArg[(A, B, C) => Z[Unit], js.Function3[A, B, C, Unit]](
      z => (a, b, c) => Z.dispatch(z(a, b, c)))(
      z => Reusable.byRef(z).withValue((a, b, c) => Z.delay(z(a, b, c))))

  implicit def c4[A, B, C, D, Z[_]](implicit Z: Dispatch[Z]): UseCallbackArg[(A, B, C, D) => Z[Unit]] =
    UseCallbackArg[(A, B, C, D) => Z[Unit], js.Function4[A, B, C, D, Unit]](
      z => (a, b, c, d) => Z.dispatch(z(a, b, c, d)))(
      z => Reusable.byRef(z).withValue((a, b, c, d) => Z.delay(z(a, b, c, d))))

  implicit def c5[A, B, C, D, E, Z[_]](implicit Z: Dispatch[Z]): UseCallbackArg[(A, B, C, D, E) => Z[Unit]] =
    UseCallbackArg[(A, B, C, D, E) => Z[Unit], js.Function5[A, B, C, D, E, Unit]](
      z => (a, b, c, d, e) => Z.dispatch(z(a, b, c, d, e)))(
      z => Reusable.byRef(z).withValue((a, b, c, d, e) => Z.delay(z(a, b, c, d, e))))

}
