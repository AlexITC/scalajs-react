package japgolly.scalajs.react.hooks

// DO NOT MANUALLY EDIT
// DO NOT MANUALLY EDIT
//
// THIS IS GENERATED BY RUNNING genHooks IN SBT
//
// DO NOT MANUALLY EDIT
// DO NOT MANUALLY EDIT

import japgolly.scalajs.react.PropsChildren
import japgolly.scalajs.react.hooks.CustomHook.{Builder => Custom}
import japgolly.scalajs.react.hooks.HookComponentBuilder._
import scala.scalajs.js

trait ComponentP_SubsequentDsl { self: ComponentP.Subsequent.type =>
  sealed trait AtStep1[P, H1] { type Next[H2] = ComponentP.Subsequent[P, HookCtx.P2[P, H1, H2], ({ type F[A] = js.Function3[P, H1, H2, A] })#F] }
  sealed trait AtStep2[P, H1, H2] { type Next[H3] = ComponentP.Subsequent[P, HookCtx.P3[P, H1, H2, H3], ({ type F[A] = js.Function4[P, H1, H2, H3, A] })#F] }
  sealed trait AtStep3[P, H1, H2, H3] { type Next[H4] = ComponentP.Subsequent[P, HookCtx.P4[P, H1, H2, H3, H4], ({ type F[A] = js.Function5[P, H1, H2, H3, H4, A] })#F] }
  sealed trait AtStep4[P, H1, H2, H3, H4] { type Next[H5] = ComponentP.Subsequent[P, HookCtx.P5[P, H1, H2, H3, H4, H5], ({ type F[A] = js.Function6[P, H1, H2, H3, H4, H5, A] })#F] }
}

trait ComponentP_SubsequentSteps { self: ComponentP.SubsequentStep.type =>

  type AtStep1[P, H1] = To[
    P,
    HookCtx.P1[P, H1],
    ({ type F[A] = js.Function2[P, H1, A] })#F,
    ComponentP.Subsequent.AtStep1[P, H1]#Next]

  implicit def atStep1[P, H1]: AtStep1[P, H1] =
    new ComponentP.SubsequentStep[P, HookCtx.P1[P, H1], ({ type F[A] = js.Function2[P, H1, A] })#F] {
      override type Next[H2] = ComponentP.Subsequent.AtStep1[P, H1]#Next[H2]
      override def next[H2] =
        (renderPrev, initNextHook) => {
          val renderNext: ComponentP.RenderFn[P, HookCtx.P2[P, H1, H2]] =
            render => renderPrev { ctx1 =>
              val h2 = initNextHook(ctx1)
              val ctx2 = HookCtx(ctx1.props, ctx1.hook1, h2)
              render(ctx2)
            }
          new ComponentP.Subsequent[P, HookCtx.P2[P, H1, H2], ({ type F[A] = js.Function3[P, H1, H2, A] })#F](renderNext)
        }
      // override def squash[A] = f => _.apply1(f)
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply1(ctxFn)
    }

  type AtStep2[P, H1, H2] = To[
    P,
    HookCtx.P2[P, H1, H2],
    ({ type F[A] = js.Function3[P, H1, H2, A] })#F,
    ComponentP.Subsequent.AtStep2[P, H1, H2]#Next]

  implicit def atStep2[P, H1, H2]: AtStep2[P, H1, H2] =
    new ComponentP.SubsequentStep[P, HookCtx.P2[P, H1, H2], ({ type F[A] = js.Function3[P, H1, H2, A] })#F] {
      override type Next[H3] = ComponentP.Subsequent.AtStep2[P, H1, H2]#Next[H3]
      override def next[H3] =
        (renderPrev, initNextHook) => {
          val renderNext: ComponentP.RenderFn[P, HookCtx.P3[P, H1, H2, H3]] =
            render => renderPrev { ctx2 =>
              val h3 = initNextHook(ctx2)
              val ctx3 = HookCtx(ctx2.props, ctx2.hook1, ctx2.hook2, h3)
              render(ctx3)
            }
          new ComponentP.Subsequent[P, HookCtx.P3[P, H1, H2, H3], ({ type F[A] = js.Function4[P, H1, H2, H3, A] })#F](renderNext)
        }
      // override def squash[A] = f => _.apply2(f)
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply2(ctxFn)
    }

  type AtStep3[P, H1, H2, H3] = To[
    P,
    HookCtx.P3[P, H1, H2, H3],
    ({ type F[A] = js.Function4[P, H1, H2, H3, A] })#F,
    ComponentP.Subsequent.AtStep3[P, H1, H2, H3]#Next]

  implicit def atStep3[P, H1, H2, H3]: AtStep3[P, H1, H2, H3] =
    new ComponentP.SubsequentStep[P, HookCtx.P3[P, H1, H2, H3], ({ type F[A] = js.Function4[P, H1, H2, H3, A] })#F] {
      override type Next[H4] = ComponentP.Subsequent.AtStep3[P, H1, H2, H3]#Next[H4]
      override def next[H4] =
        (renderPrev, initNextHook) => {
          val renderNext: ComponentP.RenderFn[P, HookCtx.P4[P, H1, H2, H3, H4]] =
            render => renderPrev { ctx3 =>
              val h4 = initNextHook(ctx3)
              val ctx4 = HookCtx(ctx3.props, ctx3.hook1, ctx3.hook2, ctx3.hook3, h4)
              render(ctx4)
            }
          new ComponentP.Subsequent[P, HookCtx.P4[P, H1, H2, H3, H4], ({ type F[A] = js.Function5[P, H1, H2, H3, H4, A] })#F](renderNext)
        }
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply3(ctxFn)
    }

  type AtStep4[P, H1, H2, H3, H4] = To[
    P,
    HookCtx.P4[P, H1, H2, H3, H4],
    ({ type F[A] = js.Function5[P, H1, H2, H3, H4, A] })#F,
    ComponentP.Subsequent.AtStep4[P, H1, H2, H3, H4]#Next]

  implicit def atStep4[P, H1, H2, H3, H4]: AtStep4[P, H1, H2, H3, H4] =
    new ComponentP.SubsequentStep[P, HookCtx.P4[P, H1, H2, H3, H4], ({ type F[A] = js.Function5[P, H1, H2, H3, H4, A] })#F] {
      override type Next[H5] = ComponentP.Subsequent.AtStep4[P, H1, H2, H3, H4]#Next[H5]
      override def next[H5] =
        (renderPrev, initNextHook) => {
          val renderNext: ComponentP.RenderFn[P, HookCtx.P5[P, H1, H2, H3, H4, H5]] =
            render => renderPrev { ctx4 =>
              val h5 = initNextHook(ctx4)
              val ctx5 = HookCtx(ctx4.props, ctx4.hook1, ctx4.hook2, ctx4.hook3, ctx4.hook4, h5)
              render(ctx5)
            }
          new ComponentP.Subsequent[P, HookCtx.P5[P, H1, H2, H3, H4, H5], ({ type F[A] = js.Function6[P, H1, H2, H3, H4, H5, A] })#F](renderNext)
        }
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply4(ctxFn)
    }

}

// =====================================================================================================================

trait ComponentPC_SubsequentDsl { self: ComponentPC.Subsequent.type =>
  sealed trait AtStep1[P, H1] { type Next[H2] = ComponentPC.Subsequent[P, HookCtx.PC2[P, H1, H2], ({ type F[A] = js.Function4[P, PropsChildren, H1, H2, A] })#F] }
  sealed trait AtStep2[P, H1, H2] { type Next[H3] = ComponentPC.Subsequent[P, HookCtx.PC3[P, H1, H2, H3], ({ type F[A] = js.Function5[P, PropsChildren, H1, H2, H3, A] })#F] }
  sealed trait AtStep3[P, H1, H2, H3] { type Next[H4] = ComponentPC.Subsequent[P, HookCtx.PC4[P, H1, H2, H3, H4], ({ type F[A] = js.Function6[P, PropsChildren, H1, H2, H3, H4, A] })#F] }
  sealed trait AtStep4[P, H1, H2, H3, H4] { type Next[H5] = ComponentPC.Subsequent[P, HookCtx.PC5[P, H1, H2, H3, H4, H5], ({ type F[A] = js.Function7[P, PropsChildren, H1, H2, H3, H4, H5, A] })#F] }
}

trait ComponentPC_SubsequentSteps { self: ComponentPC.SubsequentStep.type =>

  type AtStep1[P, H1] = To[
    P,
    HookCtx.PC1[P, H1],
    ({ type F[A] = js.Function3[P, PropsChildren, H1, A] })#F,
    ComponentPC.Subsequent.AtStep1[P, H1]#Next]

  implicit def atStep1[P, H1]: AtStep1[P, H1] =
    new ComponentPC.SubsequentStep[P, HookCtx.PC1[P, H1], ({ type F[A] = js.Function3[P, PropsChildren, H1, A] })#F] {
      override type Next[H2] = ComponentPC.Subsequent.AtStep1[P, H1]#Next[H2]
      override def next[H2] =
        (renderPrev, initNextHook) => {
          val renderNext: ComponentPC.RenderFn[P, HookCtx.PC2[P, H1, H2]] =
            render => renderPrev { ctx1 =>
              val h2 = initNextHook(ctx1)
              val ctx2 = HookCtx.withChildren(ctx1.props, ctx1.propsChildren, ctx1.hook1, h2)
              render(ctx2)
            }
          new ComponentPC.Subsequent[P, HookCtx.PC2[P, H1, H2], ({ type F[A] = js.Function4[P, PropsChildren, H1, H2, A] })#F](renderNext)
        }
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply1(ctxFn)
    }

  type AtStep2[P, H1, H2] = To[
    P,
    HookCtx.PC2[P, H1, H2],
    ({ type F[A] = js.Function4[P, PropsChildren, H1, H2, A] })#F,
    ComponentPC.Subsequent.AtStep2[P, H1, H2]#Next]

  implicit def atStep2[P, H1, H2]: AtStep2[P, H1, H2] =
    new ComponentPC.SubsequentStep[P, HookCtx.PC2[P, H1, H2], ({ type F[A] = js.Function4[P, PropsChildren, H1, H2, A] })#F] {
      override type Next[H3] = ComponentPC.Subsequent.AtStep2[P, H1, H2]#Next[H3]
      override def next[H3] =
        (renderPrev, initNextHook) => {
          val renderNext: ComponentPC.RenderFn[P, HookCtx.PC3[P, H1, H2, H3]] =
            render => renderPrev { ctx2 =>
              val h3 = initNextHook(ctx2)
              val ctx3 = HookCtx.withChildren(ctx2.props, ctx2.propsChildren, ctx2.hook1, ctx2.hook2, h3)
              render(ctx3)
            }
          new ComponentPC.Subsequent[P, HookCtx.PC3[P, H1, H2, H3], ({ type F[A] = js.Function5[P, PropsChildren, H1, H2, H3, A] })#F](renderNext)
        }
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply2(ctxFn)
    }

  type AtStep3[P, H1, H2, H3] = To[
    P,
    HookCtx.PC3[P, H1, H2, H3],
    ({ type F[A] = js.Function5[P, PropsChildren, H1, H2, H3, A] })#F,
    ComponentPC.Subsequent.AtStep3[P, H1, H2, H3]#Next]

  implicit def atStep3[P, H1, H2, H3]: AtStep3[P, H1, H2, H3] =
    new ComponentPC.SubsequentStep[P, HookCtx.PC3[P, H1, H2, H3], ({ type F[A] = js.Function5[P, PropsChildren, H1, H2, H3, A] })#F] {
      override type Next[H4] = ComponentPC.Subsequent.AtStep3[P, H1, H2, H3]#Next[H4]
      override def next[H4] =
        (renderPrev, initNextHook) => {
          val renderNext: ComponentPC.RenderFn[P, HookCtx.PC4[P, H1, H2, H3, H4]] =
            render => renderPrev { ctx3 =>
              val h4 = initNextHook(ctx3)
              val ctx4 = HookCtx.withChildren(ctx3.props, ctx3.propsChildren, ctx3.hook1, ctx3.hook2, ctx3.hook3, h4)
              render(ctx4)
            }
          new ComponentPC.Subsequent[P, HookCtx.PC4[P, H1, H2, H3, H4], ({ type F[A] = js.Function6[P, PropsChildren, H1, H2, H3, H4, A] })#F](renderNext)
        }
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply3(ctxFn)
    }

  type AtStep4[P, H1, H2, H3, H4] = To[
    P,
    HookCtx.PC4[P, H1, H2, H3, H4],
    ({ type F[A] = js.Function6[P, PropsChildren, H1, H2, H3, H4, A] })#F,
    ComponentPC.Subsequent.AtStep4[P, H1, H2, H3, H4]#Next]

  implicit def atStep4[P, H1, H2, H3, H4]: AtStep4[P, H1, H2, H3, H4] =
    new ComponentPC.SubsequentStep[P, HookCtx.PC4[P, H1, H2, H3, H4], ({ type F[A] = js.Function6[P, PropsChildren, H1, H2, H3, H4, A] })#F] {
      override type Next[H5] = ComponentPC.Subsequent.AtStep4[P, H1, H2, H3, H4]#Next[H5]
      override def next[H5] =
        (renderPrev, initNextHook) => {
          val renderNext: ComponentPC.RenderFn[P, HookCtx.PC5[P, H1, H2, H3, H4, H5]] =
            render => renderPrev { ctx4 =>
              val h5 = initNextHook(ctx4)
              val ctx5 = HookCtx.withChildren(ctx4.props, ctx4.propsChildren, ctx4.hook1, ctx4.hook2, ctx4.hook3, ctx4.hook4, h5)
              render(ctx5)
            }
          new ComponentPC.Subsequent[P, HookCtx.PC5[P, H1, H2, H3, H4, H5], ({ type F[A] = js.Function7[P, PropsChildren, H1, H2, H3, H4, H5, A] })#F](renderNext)
        }
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply4(ctxFn)
    }

}

// =====================================================================================================================

trait Custom_SubsequentDsl { self: Custom.Subsequent.type =>
  sealed trait AtStep1[I, H1] { type Next[H2] = Custom.Subsequent[I, HookCtx.I2[I, H1, H2], ({ type F[A] = js.Function3[I, H1, H2, A] })#F] }
  sealed trait AtStep2[I, H1, H2] { type Next[H3] = Custom.Subsequent[I, HookCtx.I3[I, H1, H2, H3], ({ type F[A] = js.Function4[I, H1, H2, H3, A] })#F] }
  sealed trait AtStep3[I, H1, H2, H3] { type Next[H4] = Custom.Subsequent[I, HookCtx.I4[I, H1, H2, H3, H4], ({ type F[A] = js.Function5[I, H1, H2, H3, H4, A] })#F] }
  sealed trait AtStep4[I, H1, H2, H3, H4] { type Next[H5] = Custom.Subsequent[I, HookCtx.I5[I, H1, H2, H3, H4, H5], ({ type F[A] = js.Function6[I, H1, H2, H3, H4, H5, A] })#F] }
}

trait Custom_SubsequentSteps { self: Custom.SubsequentStep.type =>

  type AtStep1[I, H1] = To[
    I,
    HookCtx.I1[I, H1],
    ({ type F[A] = js.Function2[I, H1, A] })#F,
    Custom.Subsequent.AtStep1[I, H1]#Next]

  implicit def atStep1[I, H1]: AtStep1[I, H1] =
    new Custom.SubsequentStep[I, HookCtx.I1[I, H1], ({ type F[A] = js.Function2[I, H1, A] })#F] {
      override type Next[H2] = Custom.Subsequent.AtStep1[I, H1]#Next[H2]
      override def next[H2] =
        (buildPrev, initNextHook) => {
          val buildNext: Custom.BuildFn[I, HookCtx.I2[I, H1, H2]] =
            new Custom.BuildFn[I, HookCtx.I2[I, H1, H2]] {
              override def apply[O](f: js.Function1[HookCtx.I2[I, H1, H2], O]) = {
                buildPrev { ctx1 =>
                  val h2 = initNextHook(ctx1)
                  val ctx2 = HookCtx.withInput(ctx1.input, ctx1.hook1, h2)
                  f(ctx2)
                }
              }
            }
          new Custom.Subsequent[I, HookCtx.I2[I, H1, H2], ({ type F[A] = js.Function3[I, H1, H2, A] })#F](buildNext)
        }
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply1(ctxFn)
    }

  type AtStep2[I, H1, H2] = To[
    I,
    HookCtx.I2[I, H1, H2],
    ({ type F[A] = js.Function3[I, H1, H2, A] })#F,
    Custom.Subsequent.AtStep2[I, H1, H2]#Next]

  implicit def atStep2[I, H1, H2]: AtStep2[I, H1, H2] =
    new Custom.SubsequentStep[I, HookCtx.I2[I, H1, H2], ({ type F[A] = js.Function3[I, H1, H2, A] })#F] {
      override type Next[H3] = Custom.Subsequent.AtStep2[I, H1, H2]#Next[H3]
      override def next[H3] =
        (buildPrev, initNextHook) => {
          val buildNext: Custom.BuildFn[I, HookCtx.I3[I, H1, H2, H3]] =
            new Custom.BuildFn[I, HookCtx.I3[I, H1, H2, H3]] {
              override def apply[O](f: js.Function1[HookCtx.I3[I, H1, H2, H3], O]) = {
                buildPrev { ctx2 =>
                  val h3 = initNextHook(ctx2)
                  val ctx3 = HookCtx.withInput(ctx2.input, ctx2.hook1, ctx2.hook2, h3)
                  f(ctx3)
                }
              }
            }
          new Custom.Subsequent[I, HookCtx.I3[I, H1, H2, H3], ({ type F[A] = js.Function4[I, H1, H2, H3, A] })#F](buildNext)
        }
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply2(ctxFn)
    }

  type AtStep3[I, H1, H2, H3] = To[
    I,
    HookCtx.I3[I, H1, H2, H3],
    ({ type F[A] = js.Function4[I, H1, H2, H3, A] })#F,
    Custom.Subsequent.AtStep3[I, H1, H2, H3]#Next]

  implicit def atStep3[I, H1, H2, H3]: AtStep3[I, H1, H2, H3] =
    new Custom.SubsequentStep[I, HookCtx.I3[I, H1, H2, H3], ({ type F[A] = js.Function4[I, H1, H2, H3, A] })#F] {
      override type Next[H4] = Custom.Subsequent.AtStep3[I, H1, H2, H3]#Next[H4]
      override def next[H4] =
        (buildPrev, initNextHook) => {
          val buildNext: Custom.BuildFn[I, HookCtx.I4[I, H1, H2, H3, H4]] =
            new Custom.BuildFn[I, HookCtx.I4[I, H1, H2, H3, H4]] {
              override def apply[O](f: js.Function1[HookCtx.I4[I, H1, H2, H3, H4], O]) = {
                buildPrev { ctx3 =>
                  val h4 = initNextHook(ctx3)
                  val ctx4 = HookCtx.withInput(ctx3.input, ctx3.hook1, ctx3.hook2, ctx3.hook3, h4)
                  f(ctx4)
                }
              }
            }
          new Custom.Subsequent[I, HookCtx.I4[I, H1, H2, H3, H4], ({ type F[A] = js.Function5[I, H1, H2, H3, H4, A] })#F](buildNext)
        }
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply3(ctxFn)
    }

  type AtStep4[I, H1, H2, H3, H4] = To[
    I,
    HookCtx.I4[I, H1, H2, H3, H4],
    ({ type F[A] = js.Function5[I, H1, H2, H3, H4, A] })#F,
    Custom.Subsequent.AtStep4[I, H1, H2, H3, H4]#Next]

  implicit def atStep4[I, H1, H2, H3, H4]: AtStep4[I, H1, H2, H3, H4] =
    new Custom.SubsequentStep[I, HookCtx.I4[I, H1, H2, H3, H4], ({ type F[A] = js.Function5[I, H1, H2, H3, H4, A] })#F] {
      override type Next[H5] = Custom.Subsequent.AtStep4[I, H1, H2, H3, H4]#Next[H5]
      override def next[H5] =
        (buildPrev, initNextHook) => {
          val buildNext: Custom.BuildFn[I, HookCtx.I5[I, H1, H2, H3, H4, H5]] =
            new Custom.BuildFn[I, HookCtx.I5[I, H1, H2, H3, H4, H5]] {
              override def apply[O](f: js.Function1[HookCtx.I5[I, H1, H2, H3, H4, H5], O]) = {
                buildPrev { ctx4 =>
                  val h5 = initNextHook(ctx4)
                  val ctx5 = HookCtx.withInput(ctx4.input, ctx4.hook1, ctx4.hook2, ctx4.hook3, ctx4.hook4, h5)
                  f(ctx5)
                }
              }
            }
          new Custom.Subsequent[I, HookCtx.I5[I, H1, H2, H3, H4, H5], ({ type F[A] = js.Function6[I, H1, H2, H3, H4, H5, A] })#F](buildNext)
        }
      @inline def squash[A](ctxFn: CtxFn[A]): js.Function1[Ctx, A] = _.apply4(ctxFn)
    }

}
