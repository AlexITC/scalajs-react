package japgolly.scalajs.react.hooks

// DO NOT MANUALLY EDIT
// DO NOT MANUALLY EDIT
//
// THIS IS GENERATED BY RUNNING genHooks IN SBT
//
// DO NOT MANUALLY EDIT
// DO NOT MANUALLY EDIT

import japgolly.scalajs.react.{PropsChildren, Reusability}
import scala.scalajs.js

object HookCtx {

  def apply[P, H1](props: P, hook1: H1): P1[P, H1] =
    new P1(props, hook1)

  def apply[P, H1, H2](props: P, hook1: H1, hook2: H2): P2[P, H1, H2] =
    new P2(props, hook1, hook2)

  def apply[P, H1, H2, H3](props: P, hook1: H1, hook2: H2, hook3: H3): P3[P, H1, H2, H3] =
    new P3(props, hook1, hook2, hook3)

  def apply[P, H1, H2, H3, H4](props: P, hook1: H1, hook2: H2, hook3: H3, hook4: H4): P4[P, H1, H2, H3, H4] =
    new P4(props, hook1, hook2, hook3, hook4)

  def apply[P, H1, H2, H3, H4, H5](props: P, hook1: H1, hook2: H2, hook3: H3, hook4: H4, hook5: H5): P5[P, H1, H2, H3, H4, H5] =
    new P5(props, hook1, hook2, hook3, hook4, hook5)

  abstract class P0[+P](@inline final val props: P)

  implicit def reusabilityP0[P](implicit P: Reusability[P]): Reusability[P0[P]] =
    Reusability.by(_.props)

  class P1[+P, +H1](props: P, @inline final val hook1: H1) extends P0(props) {
    override def toString = s"HookCtx(\n  props = $props,\n  hook1 = $hook1)"
    @inline final def apply1[A](f: js.Function2[P, H1, A]): A = f(props, hook1)
  }

  implicit def reusabilityP1[P, H1](implicit P: Reusability[P], H1: Reusability[H1]): Reusability[P1[P, H1]] =
    Reusability((x, y) => P.test(x.props, y.props) && H1.test(x.hook1, y.hook1))

  class P2[+P, +H1, +H2](props: P, hook1: H1, @inline final val hook2: H2) extends P1(props, hook1) {
    override def toString = s"HookCtx(\n  props = $props,\n  hook1 = $hook1,\n  hook2 = $hook2)"
    @inline final def apply2[A](f: js.Function3[P, H1, H2, A]): A = f(props, hook1, hook2)
  }

  implicit def reusabilityP2[P, H1, H2](implicit P: Reusability[P], H1: Reusability[H1], H2: Reusability[H2]): Reusability[P2[P, H1, H2]] =
    Reusability((x, y) => P.test(x.props, y.props) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2))

  class P3[+P, +H1, +H2, +H3](props: P, hook1: H1, hook2: H2, final val hook3: H3) extends P2(props, hook1, hook2) {
    override def toString = s"HookCtx(\n  props = $props,\n  hook1 = $hook1,\n  hook2 = $hook2,\n  hook3 = $hook3)"
    @inline final def apply3[A](f: js.Function4[P, H1, H2, H3, A]): A = f(props, hook1, hook2, hook3)
  }

  implicit def reusabilityP3[P, H1, H2, H3](implicit P: Reusability[P], H1: Reusability[H1], H2: Reusability[H2], H3: Reusability[H3]): Reusability[P3[P, H1, H2, H3]] =
    Reusability((x, y) => P.test(x.props, y.props) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2) && H3.test(x.hook3, y.hook3))

  class P4[+P, +H1, +H2, +H3, +H4](props: P, hook1: H1, hook2: H2, hook3: H3, final val hook4: H4) extends P3(props, hook1, hook2, hook3) {
    override def toString = s"HookCtx(\n  props = $props,\n  hook1 = $hook1,\n  hook2 = $hook2,\n  hook3 = $hook3,\n  hook4 = $hook4)"
    @inline final def apply4[A](f: js.Function5[P, H1, H2, H3, H4, A]): A = f(props, hook1, hook2, hook3, hook4)
  }

  implicit def reusabilityP4[P, H1, H2, H3, H4](implicit P: Reusability[P], H1: Reusability[H1], H2: Reusability[H2], H3: Reusability[H3], H4: Reusability[H4]): Reusability[P4[P, H1, H2, H3, H4]] =
    Reusability((x, y) => P.test(x.props, y.props) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2) && H3.test(x.hook3, y.hook3) && H4.test(x.hook4, y.hook4))

  class P5[+P, +H1, +H2, +H3, +H4, +H5](props: P, hook1: H1, hook2: H2, hook3: H3, hook4: H4, final val hook5: H5) extends P4(props, hook1, hook2, hook3, hook4) {
    override def toString = s"HookCtx(\n  props = $props,\n  hook1 = $hook1,\n  hook2 = $hook2,\n  hook3 = $hook3,\n  hook4 = $hook4,\n  hook5 = $hook5)"
    @inline final def apply5[A](f: js.Function6[P, H1, H2, H3, H4, H5, A]): A = f(props, hook1, hook2, hook3, hook4, hook5)
  }

  implicit def reusabilityP5[P, H1, H2, H3, H4, H5](implicit P: Reusability[P], H1: Reusability[H1], H2: Reusability[H2], H3: Reusability[H3], H4: Reusability[H4], H5: Reusability[H5]): Reusability[P5[P, H1, H2, H3, H4, H5]] =
    Reusability((x, y) => P.test(x.props, y.props) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2) && H3.test(x.hook3, y.hook3) && H4.test(x.hook4, y.hook4) && H5.test(x.hook5, y.hook5))

  // ===================================================================================================================

  object withChildren {

    def apply[P](props: P, propsChildren: PropsChildren): PC0[P] =
      new PC0(props, propsChildren)

    def apply[P, H1](props: P, propsChildren: PropsChildren, hook1: H1): PC1[P, H1] =
      new PC1(props, propsChildren, hook1)

    def apply[P, H1, H2](props: P, propsChildren: PropsChildren, hook1: H1, hook2: H2): PC2[P, H1, H2] =
      new PC2(props, propsChildren, hook1, hook2)

    def apply[P, H1, H2, H3](props: P, propsChildren: PropsChildren, hook1: H1, hook2: H2, hook3: H3): PC3[P, H1, H2, H3] =
      new PC3(props, propsChildren, hook1, hook2, hook3)

    def apply[P, H1, H2, H3, H4](props: P, propsChildren: PropsChildren, hook1: H1, hook2: H2, hook3: H3, hook4: H4): PC4[P, H1, H2, H3, H4] =
      new PC4(props, propsChildren, hook1, hook2, hook3, hook4)

    def apply[P, H1, H2, H3, H4, H5](props: P, propsChildren: PropsChildren, hook1: H1, hook2: H2, hook3: H3, hook4: H4, hook5: H5): PC5[P, H1, H2, H3, H4, H5] =
      new PC5(props, propsChildren, hook1, hook2, hook3, hook4, hook5)
  }

  class PC0[+P](props: P, final val propsChildren: PropsChildren) extends P0(props)

  implicit def reusabilityPC0[P](implicit P: Reusability[P], PC: Reusability[PropsChildren]): Reusability[PC0[P]] =
    Reusability((x, y) => P.test(x.props, y.props) && PC.test(x.propsChildren, y.propsChildren))

  class PC1[+P, +H1](props: P, propsChildren: PropsChildren, final val hook1: H1) extends PC0(props, propsChildren) {
    override def toString = s"HookCtx.withChildren(\n  props = $props,\n  propsChildren = $propsChildren,\n  hook1 = $hook1)"
    def apply1[A](f: (P, PropsChildren, H1) => A): A = f(props, propsChildren, hook1)
  }

  implicit def reusabilityPC1[P, H1](implicit P: Reusability[P], PC: Reusability[PropsChildren], H1: Reusability[H1]): Reusability[PC1[P, H1]] =
    Reusability((x, y) => P.test(x.props, y.props) && PC.test(x.propsChildren, y.propsChildren) && H1.test(x.hook1, y.hook1))

  class PC2[+P, +H1, +H2](props: P, propsChildren: PropsChildren, hook1: H1, final val hook2: H2) extends PC1(props, propsChildren, hook1) {
    override def toString = s"HookCtx.withChildren(\n  props = $props,\n  propsChildren = $propsChildren,\n  hook1 = $hook1,\n  hook2 = $hook2)"
    def apply2[A](f: (P, PropsChildren, H1, H2) => A): A = f(props, propsChildren, hook1, hook2)
  }

  implicit def reusabilityPC2[P, H1, H2](implicit P: Reusability[P], PC: Reusability[PropsChildren], H1: Reusability[H1], H2: Reusability[H2]): Reusability[PC2[P, H1, H2]] =
    Reusability((x, y) => P.test(x.props, y.props) && PC.test(x.propsChildren, y.propsChildren) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2))

  class PC3[+P, +H1, +H2, +H3](props: P, propsChildren: PropsChildren, hook1: H1, hook2: H2, final val hook3: H3) extends PC2(props, propsChildren, hook1, hook2) {
    override def toString = s"HookCtx.withChildren(\n  props = $props,\n  propsChildren = $propsChildren,\n  hook1 = $hook1,\n  hook2 = $hook2,\n  hook3 = $hook3)"
    def apply3[A](f: (P, PropsChildren, H1, H2, H3) => A): A = f(props, propsChildren, hook1, hook2, hook3)
  }

  implicit def reusabilityPC3[P, H1, H2, H3](implicit P: Reusability[P], PC: Reusability[PropsChildren], H1: Reusability[H1], H2: Reusability[H2], H3: Reusability[H3]): Reusability[PC3[P, H1, H2, H3]] =
    Reusability((x, y) => P.test(x.props, y.props) && PC.test(x.propsChildren, y.propsChildren) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2) && H3.test(x.hook3, y.hook3))

  class PC4[+P, +H1, +H2, +H3, +H4](props: P, propsChildren: PropsChildren, hook1: H1, hook2: H2, hook3: H3, final val hook4: H4) extends PC3(props, propsChildren, hook1, hook2, hook3) {
    override def toString = s"HookCtx.withChildren(\n  props = $props,\n  propsChildren = $propsChildren,\n  hook1 = $hook1,\n  hook2 = $hook2,\n  hook3 = $hook3,\n  hook4 = $hook4)"
    def apply4[A](f: (P, PropsChildren, H1, H2, H3, H4) => A): A = f(props, propsChildren, hook1, hook2, hook3, hook4)
  }

  implicit def reusabilityPC4[P, H1, H2, H3, H4](implicit P: Reusability[P], PC: Reusability[PropsChildren], H1: Reusability[H1], H2: Reusability[H2], H3: Reusability[H3], H4: Reusability[H4]): Reusability[PC4[P, H1, H2, H3, H4]] =
    Reusability((x, y) => P.test(x.props, y.props) && PC.test(x.propsChildren, y.propsChildren) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2) && H3.test(x.hook3, y.hook3) && H4.test(x.hook4, y.hook4))

  class PC5[+P, +H1, +H2, +H3, +H4, +H5](props: P, propsChildren: PropsChildren, hook1: H1, hook2: H2, hook3: H3, hook4: H4, final val hook5: H5) extends PC4(props, propsChildren, hook1, hook2, hook3, hook4) {
    override def toString = s"HookCtx.withChildren(\n  props = $props,\n  propsChildren = $propsChildren,\n  hook1 = $hook1,\n  hook2 = $hook2,\n  hook3 = $hook3,\n  hook4 = $hook4,\n  hook5 = $hook5)"
    def apply5[A](f: (P, PropsChildren, H1, H2, H3, H4, H5) => A): A = f(props, propsChildren, hook1, hook2, hook3, hook4, hook5)
  }

  implicit def reusabilityPC5[P, H1, H2, H3, H4, H5](implicit P: Reusability[P], PC: Reusability[PropsChildren], H1: Reusability[H1], H2: Reusability[H2], H3: Reusability[H3], H4: Reusability[H4], H5: Reusability[H5]): Reusability[PC5[P, H1, H2, H3, H4, H5]] =
    Reusability((x, y) => P.test(x.props, y.props) && PC.test(x.propsChildren, y.propsChildren) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2) && H3.test(x.hook3, y.hook3) && H4.test(x.hook4, y.hook4) && H5.test(x.hook5, y.hook5))


  // ===================================================================================================================

  object withInput {

    def apply[I](input: I): I0[I] =
      new I0(input)

    def apply[I, H1](input: I, hook1: H1): I1[I, H1] =
      new I1(input, hook1)

    def apply[I, H1, H2](input: I, hook1: H1, hook2: H2): I2[I, H1, H2] =
      new I2(input, hook1, hook2)

    def apply[I, H1, H2, H3](input: I, hook1: H1, hook2: H2, hook3: H3): I3[I, H1, H2, H3] =
      new I3(input, hook1, hook2, hook3)

    def apply[I, H1, H2, H3, H4](input: I, hook1: H1, hook2: H2, hook3: H3, hook4: H4): I4[I, H1, H2, H3, H4] =
      new I4(input, hook1, hook2, hook3, hook4)

    def apply[I, H1, H2, H3, H4, H5](input: I, hook1: H1, hook2: H2, hook3: H3, hook4: H4, hook5: H5): I5[I, H1, H2, H3, H4, H5] =
      new I5(input, hook1, hook2, hook3, hook4, hook5)
  }

  class I0[+I](final val input: I)

  implicit def reusabilityI0[I](implicit I: Reusability[I]): Reusability[I0[I]] =
    Reusability.by(_.input)

  class I1[+I, +H1](input: I, final val hook1: H1) extends I0(input) {
    override def toString = s"HookCtx.withInput(\n  input = $input,\n  hook1 = $hook1)"
    def apply1[A](f: (I, H1) => A): A = f(input, hook1)
  }

  implicit def reusabilityI1[I, H1](implicit I: Reusability[I], H1: Reusability[H1]): Reusability[I1[I, H1]] =
    Reusability((x, y) => I.test(x.input, y.input) && H1.test(x.hook1, y.hook1))

  class I2[+I, +H1, +H2](input: I, hook1: H1, final val hook2: H2) extends I1(input, hook1) {
    override def toString = s"HookCtx.withInput(\n  input = $input,\n  hook1 = $hook1,\n  hook2 = $hook2)"
    def apply2[A](f: (I, H1, H2) => A): A = f(input, hook1, hook2)
  }

  implicit def reusabilityI2[I, H1, H2](implicit I: Reusability[I], H1: Reusability[H1], H2: Reusability[H2]): Reusability[I2[I, H1, H2]] =
    Reusability((x, y) => I.test(x.input, y.input) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2))

  class I3[+I, +H1, +H2, +H3](input: I, hook1: H1, hook2: H2, final val hook3: H3) extends I2(input, hook1, hook2) {
    override def toString = s"HookCtx.withInput(\n  input = $input,\n  hook1 = $hook1,\n  hook2 = $hook2,\n  hook3 = $hook3)"
    def apply3[A](f: (I, H1, H2, H3) => A): A = f(input, hook1, hook2, hook3)
  }

  implicit def reusabilityI3[I, H1, H2, H3](implicit I: Reusability[I], H1: Reusability[H1], H2: Reusability[H2], H3: Reusability[H3]): Reusability[I3[I, H1, H2, H3]] =
    Reusability((x, y) => I.test(x.input, y.input) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2) && H3.test(x.hook3, y.hook3))

  class I4[+I, +H1, +H2, +H3, +H4](input: I, hook1: H1, hook2: H2, hook3: H3, final val hook4: H4) extends I3(input, hook1, hook2, hook3) {
    override def toString = s"HookCtx.withInput(\n  input = $input,\n  hook1 = $hook1,\n  hook2 = $hook2,\n  hook3 = $hook3,\n  hook4 = $hook4)"
    def apply4[A](f: (I, H1, H2, H3, H4) => A): A = f(input, hook1, hook2, hook3, hook4)
  }

  implicit def reusabilityI4[I, H1, H2, H3, H4](implicit I: Reusability[I], H1: Reusability[H1], H2: Reusability[H2], H3: Reusability[H3], H4: Reusability[H4]): Reusability[I4[I, H1, H2, H3, H4]] =
    Reusability((x, y) => I.test(x.input, y.input) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2) && H3.test(x.hook3, y.hook3) && H4.test(x.hook4, y.hook4))

  class I5[+I, +H1, +H2, +H3, +H4, +H5](input: I, hook1: H1, hook2: H2, hook3: H3, hook4: H4, final val hook5: H5) extends I4(input, hook1, hook2, hook3, hook4) {
    override def toString = s"HookCtx.withInput(\n  input = $input,\n  hook1 = $hook1,\n  hook2 = $hook2,\n  hook3 = $hook3,\n  hook4 = $hook4,\n  hook5 = $hook5)"
    def apply5[A](f: (I, H1, H2, H3, H4, H5) => A): A = f(input, hook1, hook2, hook3, hook4, hook5)
  }

  implicit def reusabilityI5[I, H1, H2, H3, H4, H5](implicit I: Reusability[I], H1: Reusability[H1], H2: Reusability[H2], H3: Reusability[H3], H4: Reusability[H4], H5: Reusability[H5]): Reusability[I5[I, H1, H2, H3, H4, H5]] =
    Reusability((x, y) => I.test(x.input, y.input) && H1.test(x.hook1, y.hook1) && H2.test(x.hook2, y.hook2) && H3.test(x.hook3, y.hook3) && H4.test(x.hook4, y.hook4) && H5.test(x.hook5, y.hook5))

}
