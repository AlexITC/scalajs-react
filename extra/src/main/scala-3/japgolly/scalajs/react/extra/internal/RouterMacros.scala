package japgolly.scalajs.react.extra.internal

import japgolly.microlibs.macro_utils.MacroUtils
import japgolly.scalajs.react.extra.router.StaticDsl.{Route, RouteB, RouteCommon}
import japgolly.scalajs.react.internal.NewMacroUtils
import japgolly.scalajs.react.internal.NewMacroUtils.Extensions._
import japgolly.scalajs.react.internal.NewMacroUtils.failNoStack
import scala.compiletime.*
import scala.deriving.Mirror
import scala.language.`3.0`

// This is here in .internal because users are expected to import router._ and it's
// better if this isn't visible and imported with the rest of the package.
object RouterMacros {

  trait ForRoute [A] extends Common[Route, A] { self: Route[A] => }
  trait ForRouteB[A] extends Common[RouteB, A] { self: RouteB[A] => }

  trait Common[R[x] <: RouteCommon[R,x], A] { self: RouteCommon[R, A] =>

    /** Maps the captures values of the route to a case class. */
    inline def caseClass[B <: scala.Product](using m: Mirror.ProductOf[B]): R[B] =
      inline erasedValue[m.MirroredElemTypes] match {

        case EmptyTuple =>
          summonFrom { case given (A =:= Unit) =>
            summonFrom { case given (Unit =:= A) =>
              self.const[B](m.fromProduct(EmptyTuple))
            }
          }

        case _ =>
          summonFrom { case given (A =:= m.MirroredElemTypes) =>
            self.xmap[B](
              a => m.fromProduct(a.asInstanceOf[m.MirroredElemTypes]))(
              b => Tuple.fromProduct(b).asInstanceOf[A])
          }
      }

    /** Same as [[caseClass]] except the code generated by the macro is printed to stdout. */
    inline def caseClassDebug[B <: scala.Product](using m: Mirror.ProductOf[B]): R[B] =
      ${ NewMacroUtils.show('{ caseClass[B] }) }

  }
}
