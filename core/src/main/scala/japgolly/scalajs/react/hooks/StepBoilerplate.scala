package japgolly.scalajs.react.hooks

// DO NOT MANUALLY EDIT
// DO NOT MANUALLY EDIT
//
// THIS IS GENERATED BY RUNNING genHooks IN SBT
//
// DO NOT MANUALLY EDIT
// DO NOT MANUALLY EDIT

import HookComponentBuilder._

trait DslMultiSteps { self: DslMulti.type =>
  sealed trait AtStep1[P, H1] { type Next[H2] = DslMulti[P, HookCtx.P2[P, H1, H2], HookCtxFn.P2[P, H1, H2]#Fn] }
  sealed trait AtStep2[P, H1, H2] { type Next[H3] = DslMulti[P, HookCtx.P3[P, H1, H2, H3], HookCtxFn.P3[P, H1, H2, H3]#Fn] }
  sealed trait AtStep3[P, H1, H2, H3] { type Next[H4] = DslMulti[P, HookCtx.P4[P, H1, H2, H3, H4], HookCtxFn.P4[P, H1, H2, H3, H4]#Fn] }
  sealed trait AtStep4[P, H1, H2, H3, H4] { type Next[H5] = DslMulti[P, HookCtx.P5[P, H1, H2, H3, H4, H5], HookCtxFn.P5[P, H1, H2, H3, H4, H5]#Fn] }
  sealed trait AtStep5[P, H1, H2, H3, H4, H5] { type Next[H6] = DslMulti[P, HookCtx.P6[P, H1, H2, H3, H4, H5, H6], HookCtxFn.P6[P, H1, H2, H3, H4, H5, H6]#Fn] }
  sealed trait AtStep6[P, H1, H2, H3, H4, H5, H6] { type Next[H7] = DslMulti[P, HookCtx.P7[P, H1, H2, H3, H4, H5, H6, H7], HookCtxFn.P7[P, H1, H2, H3, H4, H5, H6, H7]#Fn] }
  sealed trait AtStep7[P, H1, H2, H3, H4, H5, H6, H7] { type Next[H8] = DslMulti[P, HookCtx.P8[P, H1, H2, H3, H4, H5, H6, H7, H8], HookCtxFn.P8[P, H1, H2, H3, H4, H5, H6, H7, H8]#Fn] }
  sealed trait AtStep8[P, H1, H2, H3, H4, H5, H6, H7, H8] { type Next[H9] = DslMulti[P, HookCtx.P9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9], HookCtxFn.P9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9]#Fn] }
  sealed trait AtStep9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9] { type Next[H10] = DslMulti[P, HookCtx.P10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10], HookCtxFn.P10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10]#Fn] }
  sealed trait AtStep10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10] { type Next[H11] = DslMulti[P, HookCtx.P11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11], HookCtxFn.P11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11]#Fn] }
  sealed trait AtStep11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11] { type Next[H12] = DslMulti[P, HookCtx.P12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12], HookCtxFn.P12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12]#Fn] }
  sealed trait AtStep12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12] { type Next[H13] = DslMulti[P, HookCtx.P13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13], HookCtxFn.P13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13]#Fn] }
  sealed trait AtStep13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13] { type Next[H14] = DslMulti[P, HookCtx.P14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14], HookCtxFn.P14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14]#Fn] }
  sealed trait AtStep14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14] { type Next[H15] = DslMulti[P, HookCtx.P15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15], HookCtxFn.P15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15]#Fn] }
  sealed trait AtStep15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15] { type Next[H16] = DslMulti[P, HookCtx.P16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16], HookCtxFn.P16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16]#Fn] }
  sealed trait AtStep16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16] { type Next[H17] = DslMulti[P, HookCtx.P17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17], HookCtxFn.P17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17]#Fn] }
  sealed trait AtStep17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17] { type Next[H18] = DslMulti[P, HookCtx.P18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18], HookCtxFn.P18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18]#Fn] }
  sealed trait AtStep18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18] { type Next[H19] = DslMulti[P, HookCtx.P19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19], HookCtxFn.P19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19]#Fn] }
  sealed trait AtStep19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19] { type Next[H20] = DslMulti[P, HookCtx.P20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20], HookCtxFn.P20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20]#Fn] }
  sealed trait AtStep20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20] { type Next[H21] = DslMulti[P, HookCtx.P21[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20, H21], HookCtxFn.P21[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20, H21]#Fn] }
}

trait StepMultiInstances { self: StepMulti.type =>

  type AtStep1[P, H1] = To[
    P,
    HookCtx.P1[P, H1],
    HookCtxFn.P1[P, H1]#Fn,
    DslMulti.AtStep1[P, H1]#Next]

  implicit def atStep1[P, H1]: AtStep1[P, H1] =
    new StepMulti[P, HookCtx.P1[P, H1], HookCtxFn.P1[P, H1]#Fn] {
      override type Next[H2] = DslMulti.AtStep1[P, H1]#Next[H2]
      override def next[H2] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P2[P, H1, H2]] =
            render => renderPrev { ctx1 =>
              val h2 = initNextHook(ctx1)
              val ctx2 = HookCtx(ctx1.props, ctx1.hook1, h2)
              render(ctx2)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply1(f)
    }

  type AtStep2[P, H1, H2] = To[
    P,
    HookCtx.P2[P, H1, H2],
    HookCtxFn.P2[P, H1, H2]#Fn,
    DslMulti.AtStep2[P, H1, H2]#Next]

  implicit def atStep2[P, H1, H2]: AtStep2[P, H1, H2] =
    new StepMulti[P, HookCtx.P2[P, H1, H2], HookCtxFn.P2[P, H1, H2]#Fn] {
      override type Next[H3] = DslMulti.AtStep2[P, H1, H2]#Next[H3]
      override def next[H3] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P3[P, H1, H2, H3]] =
            render => renderPrev { ctx2 =>
              val h3 = initNextHook(ctx2)
              val ctx3 = HookCtx(ctx2.props, ctx2.hook1, ctx2.hook2, h3)
              render(ctx3)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply2(f)
    }

  type AtStep3[P, H1, H2, H3] = To[
    P,
    HookCtx.P3[P, H1, H2, H3],
    HookCtxFn.P3[P, H1, H2, H3]#Fn,
    DslMulti.AtStep3[P, H1, H2, H3]#Next]

  implicit def atStep3[P, H1, H2, H3]: AtStep3[P, H1, H2, H3] =
    new StepMulti[P, HookCtx.P3[P, H1, H2, H3], HookCtxFn.P3[P, H1, H2, H3]#Fn] {
      override type Next[H4] = DslMulti.AtStep3[P, H1, H2, H3]#Next[H4]
      override def next[H4] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P4[P, H1, H2, H3, H4]] =
            render => renderPrev { ctx3 =>
              val h4 = initNextHook(ctx3)
              val ctx4 = HookCtx(ctx3.props, ctx3.hook1, ctx3.hook2, ctx3.hook3, h4)
              render(ctx4)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply3(f)
    }

  type AtStep4[P, H1, H2, H3, H4] = To[
    P,
    HookCtx.P4[P, H1, H2, H3, H4],
    HookCtxFn.P4[P, H1, H2, H3, H4]#Fn,
    DslMulti.AtStep4[P, H1, H2, H3, H4]#Next]

  implicit def atStep4[P, H1, H2, H3, H4]: AtStep4[P, H1, H2, H3, H4] =
    new StepMulti[P, HookCtx.P4[P, H1, H2, H3, H4], HookCtxFn.P4[P, H1, H2, H3, H4]#Fn] {
      override type Next[H5] = DslMulti.AtStep4[P, H1, H2, H3, H4]#Next[H5]
      override def next[H5] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P5[P, H1, H2, H3, H4, H5]] =
            render => renderPrev { ctx4 =>
              val h5 = initNextHook(ctx4)
              val ctx5 = HookCtx(ctx4.props, ctx4.hook1, ctx4.hook2, ctx4.hook3, ctx4.hook4, h5)
              render(ctx5)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply4(f)
    }

  type AtStep5[P, H1, H2, H3, H4, H5] = To[
    P,
    HookCtx.P5[P, H1, H2, H3, H4, H5],
    HookCtxFn.P5[P, H1, H2, H3, H4, H5]#Fn,
    DslMulti.AtStep5[P, H1, H2, H3, H4, H5]#Next]

  implicit def atStep5[P, H1, H2, H3, H4, H5]: AtStep5[P, H1, H2, H3, H4, H5] =
    new StepMulti[P, HookCtx.P5[P, H1, H2, H3, H4, H5], HookCtxFn.P5[P, H1, H2, H3, H4, H5]#Fn] {
      override type Next[H6] = DslMulti.AtStep5[P, H1, H2, H3, H4, H5]#Next[H6]
      override def next[H6] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P6[P, H1, H2, H3, H4, H5, H6]] =
            render => renderPrev { ctx5 =>
              val h6 = initNextHook(ctx5)
              val ctx6 = HookCtx(ctx5.props, ctx5.hook1, ctx5.hook2, ctx5.hook3, ctx5.hook4, ctx5.hook5, h6)
              render(ctx6)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply5(f)
    }

  type AtStep6[P, H1, H2, H3, H4, H5, H6] = To[
    P,
    HookCtx.P6[P, H1, H2, H3, H4, H5, H6],
    HookCtxFn.P6[P, H1, H2, H3, H4, H5, H6]#Fn,
    DslMulti.AtStep6[P, H1, H2, H3, H4, H5, H6]#Next]

  implicit def atStep6[P, H1, H2, H3, H4, H5, H6]: AtStep6[P, H1, H2, H3, H4, H5, H6] =
    new StepMulti[P, HookCtx.P6[P, H1, H2, H3, H4, H5, H6], HookCtxFn.P6[P, H1, H2, H3, H4, H5, H6]#Fn] {
      override type Next[H7] = DslMulti.AtStep6[P, H1, H2, H3, H4, H5, H6]#Next[H7]
      override def next[H7] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P7[P, H1, H2, H3, H4, H5, H6, H7]] =
            render => renderPrev { ctx6 =>
              val h7 = initNextHook(ctx6)
              val ctx7 = HookCtx(ctx6.props, ctx6.hook1, ctx6.hook2, ctx6.hook3, ctx6.hook4, ctx6.hook5, ctx6.hook6, h7)
              render(ctx7)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply6(f)
    }

  type AtStep7[P, H1, H2, H3, H4, H5, H6, H7] = To[
    P,
    HookCtx.P7[P, H1, H2, H3, H4, H5, H6, H7],
    HookCtxFn.P7[P, H1, H2, H3, H4, H5, H6, H7]#Fn,
    DslMulti.AtStep7[P, H1, H2, H3, H4, H5, H6, H7]#Next]

  implicit def atStep7[P, H1, H2, H3, H4, H5, H6, H7]: AtStep7[P, H1, H2, H3, H4, H5, H6, H7] =
    new StepMulti[P, HookCtx.P7[P, H1, H2, H3, H4, H5, H6, H7], HookCtxFn.P7[P, H1, H2, H3, H4, H5, H6, H7]#Fn] {
      override type Next[H8] = DslMulti.AtStep7[P, H1, H2, H3, H4, H5, H6, H7]#Next[H8]
      override def next[H8] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P8[P, H1, H2, H3, H4, H5, H6, H7, H8]] =
            render => renderPrev { ctx7 =>
              val h8 = initNextHook(ctx7)
              val ctx8 = HookCtx(ctx7.props, ctx7.hook1, ctx7.hook2, ctx7.hook3, ctx7.hook4, ctx7.hook5, ctx7.hook6, ctx7.hook7, h8)
              render(ctx8)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply7(f)
    }

  type AtStep8[P, H1, H2, H3, H4, H5, H6, H7, H8] = To[
    P,
    HookCtx.P8[P, H1, H2, H3, H4, H5, H6, H7, H8],
    HookCtxFn.P8[P, H1, H2, H3, H4, H5, H6, H7, H8]#Fn,
    DslMulti.AtStep8[P, H1, H2, H3, H4, H5, H6, H7, H8]#Next]

  implicit def atStep8[P, H1, H2, H3, H4, H5, H6, H7, H8]: AtStep8[P, H1, H2, H3, H4, H5, H6, H7, H8] =
    new StepMulti[P, HookCtx.P8[P, H1, H2, H3, H4, H5, H6, H7, H8], HookCtxFn.P8[P, H1, H2, H3, H4, H5, H6, H7, H8]#Fn] {
      override type Next[H9] = DslMulti.AtStep8[P, H1, H2, H3, H4, H5, H6, H7, H8]#Next[H9]
      override def next[H9] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9]] =
            render => renderPrev { ctx8 =>
              val h9 = initNextHook(ctx8)
              val ctx9 = HookCtx(ctx8.props, ctx8.hook1, ctx8.hook2, ctx8.hook3, ctx8.hook4, ctx8.hook5, ctx8.hook6, ctx8.hook7, ctx8.hook8, h9)
              render(ctx9)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply8(f)
    }

  type AtStep9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9] = To[
    P,
    HookCtx.P9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9],
    HookCtxFn.P9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9]#Fn,
    DslMulti.AtStep9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9]#Next]

  implicit def atStep9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9]: AtStep9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9] =
    new StepMulti[P, HookCtx.P9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9], HookCtxFn.P9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9]#Fn] {
      override type Next[H10] = DslMulti.AtStep9[P, H1, H2, H3, H4, H5, H6, H7, H8, H9]#Next[H10]
      override def next[H10] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10]] =
            render => renderPrev { ctx9 =>
              val h10 = initNextHook(ctx9)
              val ctx10 = HookCtx(ctx9.props, ctx9.hook1, ctx9.hook2, ctx9.hook3, ctx9.hook4, ctx9.hook5, ctx9.hook6, ctx9.hook7, ctx9.hook8, ctx9.hook9, h10)
              render(ctx10)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply9(f)
    }

  type AtStep10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10] = To[
    P,
    HookCtx.P10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10],
    HookCtxFn.P10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10]#Fn,
    DslMulti.AtStep10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10]#Next]

  implicit def atStep10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10]: AtStep10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10] =
    new StepMulti[P, HookCtx.P10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10], HookCtxFn.P10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10]#Fn] {
      override type Next[H11] = DslMulti.AtStep10[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10]#Next[H11]
      override def next[H11] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11]] =
            render => renderPrev { ctx10 =>
              val h11 = initNextHook(ctx10)
              val ctx11 = HookCtx(ctx10.props, ctx10.hook1, ctx10.hook2, ctx10.hook3, ctx10.hook4, ctx10.hook5, ctx10.hook6, ctx10.hook7, ctx10.hook8, ctx10.hook9, ctx10.hook10, h11)
              render(ctx11)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply10(f)
    }

  type AtStep11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11] = To[
    P,
    HookCtx.P11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11],
    HookCtxFn.P11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11]#Fn,
    DslMulti.AtStep11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11]#Next]

  implicit def atStep11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11]: AtStep11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11] =
    new StepMulti[P, HookCtx.P11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11], HookCtxFn.P11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11]#Fn] {
      override type Next[H12] = DslMulti.AtStep11[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11]#Next[H12]
      override def next[H12] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12]] =
            render => renderPrev { ctx11 =>
              val h12 = initNextHook(ctx11)
              val ctx12 = HookCtx(ctx11.props, ctx11.hook1, ctx11.hook2, ctx11.hook3, ctx11.hook4, ctx11.hook5, ctx11.hook6, ctx11.hook7, ctx11.hook8, ctx11.hook9, ctx11.hook10, ctx11.hook11, h12)
              render(ctx12)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply11(f)
    }

  type AtStep12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12] = To[
    P,
    HookCtx.P12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12],
    HookCtxFn.P12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12]#Fn,
    DslMulti.AtStep12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12]#Next]

  implicit def atStep12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12]: AtStep12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12] =
    new StepMulti[P, HookCtx.P12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12], HookCtxFn.P12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12]#Fn] {
      override type Next[H13] = DslMulti.AtStep12[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12]#Next[H13]
      override def next[H13] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13]] =
            render => renderPrev { ctx12 =>
              val h13 = initNextHook(ctx12)
              val ctx13 = HookCtx(ctx12.props, ctx12.hook1, ctx12.hook2, ctx12.hook3, ctx12.hook4, ctx12.hook5, ctx12.hook6, ctx12.hook7, ctx12.hook8, ctx12.hook9, ctx12.hook10, ctx12.hook11, ctx12.hook12, h13)
              render(ctx13)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply12(f)
    }

  type AtStep13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13] = To[
    P,
    HookCtx.P13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13],
    HookCtxFn.P13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13]#Fn,
    DslMulti.AtStep13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13]#Next]

  implicit def atStep13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13]: AtStep13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13] =
    new StepMulti[P, HookCtx.P13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13], HookCtxFn.P13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13]#Fn] {
      override type Next[H14] = DslMulti.AtStep13[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13]#Next[H14]
      override def next[H14] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14]] =
            render => renderPrev { ctx13 =>
              val h14 = initNextHook(ctx13)
              val ctx14 = HookCtx(ctx13.props, ctx13.hook1, ctx13.hook2, ctx13.hook3, ctx13.hook4, ctx13.hook5, ctx13.hook6, ctx13.hook7, ctx13.hook8, ctx13.hook9, ctx13.hook10, ctx13.hook11, ctx13.hook12, ctx13.hook13, h14)
              render(ctx14)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply13(f)
    }

  type AtStep14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14] = To[
    P,
    HookCtx.P14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14],
    HookCtxFn.P14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14]#Fn,
    DslMulti.AtStep14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14]#Next]

  implicit def atStep14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14]: AtStep14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14] =
    new StepMulti[P, HookCtx.P14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14], HookCtxFn.P14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14]#Fn] {
      override type Next[H15] = DslMulti.AtStep14[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14]#Next[H15]
      override def next[H15] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15]] =
            render => renderPrev { ctx14 =>
              val h15 = initNextHook(ctx14)
              val ctx15 = HookCtx(ctx14.props, ctx14.hook1, ctx14.hook2, ctx14.hook3, ctx14.hook4, ctx14.hook5, ctx14.hook6, ctx14.hook7, ctx14.hook8, ctx14.hook9, ctx14.hook10, ctx14.hook11, ctx14.hook12, ctx14.hook13, ctx14.hook14, h15)
              render(ctx15)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply14(f)
    }

  type AtStep15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15] = To[
    P,
    HookCtx.P15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15],
    HookCtxFn.P15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15]#Fn,
    DslMulti.AtStep15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15]#Next]

  implicit def atStep15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15]: AtStep15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15] =
    new StepMulti[P, HookCtx.P15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15], HookCtxFn.P15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15]#Fn] {
      override type Next[H16] = DslMulti.AtStep15[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15]#Next[H16]
      override def next[H16] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16]] =
            render => renderPrev { ctx15 =>
              val h16 = initNextHook(ctx15)
              val ctx16 = HookCtx(ctx15.props, ctx15.hook1, ctx15.hook2, ctx15.hook3, ctx15.hook4, ctx15.hook5, ctx15.hook6, ctx15.hook7, ctx15.hook8, ctx15.hook9, ctx15.hook10, ctx15.hook11, ctx15.hook12, ctx15.hook13, ctx15.hook14, ctx15.hook15, h16)
              render(ctx16)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply15(f)
    }

  type AtStep16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16] = To[
    P,
    HookCtx.P16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16],
    HookCtxFn.P16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16]#Fn,
    DslMulti.AtStep16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16]#Next]

  implicit def atStep16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16]: AtStep16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16] =
    new StepMulti[P, HookCtx.P16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16], HookCtxFn.P16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16]#Fn] {
      override type Next[H17] = DslMulti.AtStep16[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16]#Next[H17]
      override def next[H17] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17]] =
            render => renderPrev { ctx16 =>
              val h17 = initNextHook(ctx16)
              val ctx17 = HookCtx(ctx16.props, ctx16.hook1, ctx16.hook2, ctx16.hook3, ctx16.hook4, ctx16.hook5, ctx16.hook6, ctx16.hook7, ctx16.hook8, ctx16.hook9, ctx16.hook10, ctx16.hook11, ctx16.hook12, ctx16.hook13, ctx16.hook14, ctx16.hook15, ctx16.hook16, h17)
              render(ctx17)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply16(f)
    }

  type AtStep17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17] = To[
    P,
    HookCtx.P17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17],
    HookCtxFn.P17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17]#Fn,
    DslMulti.AtStep17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17]#Next]

  implicit def atStep17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17]: AtStep17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17] =
    new StepMulti[P, HookCtx.P17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17], HookCtxFn.P17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17]#Fn] {
      override type Next[H18] = DslMulti.AtStep17[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17]#Next[H18]
      override def next[H18] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18]] =
            render => renderPrev { ctx17 =>
              val h18 = initNextHook(ctx17)
              val ctx18 = HookCtx(ctx17.props, ctx17.hook1, ctx17.hook2, ctx17.hook3, ctx17.hook4, ctx17.hook5, ctx17.hook6, ctx17.hook7, ctx17.hook8, ctx17.hook9, ctx17.hook10, ctx17.hook11, ctx17.hook12, ctx17.hook13, ctx17.hook14, ctx17.hook15, ctx17.hook16, ctx17.hook17, h18)
              render(ctx18)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply17(f)
    }

  type AtStep18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18] = To[
    P,
    HookCtx.P18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18],
    HookCtxFn.P18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18]#Fn,
    DslMulti.AtStep18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18]#Next]

  implicit def atStep18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18]: AtStep18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18] =
    new StepMulti[P, HookCtx.P18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18], HookCtxFn.P18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18]#Fn] {
      override type Next[H19] = DslMulti.AtStep18[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18]#Next[H19]
      override def next[H19] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19]] =
            render => renderPrev { ctx18 =>
              val h19 = initNextHook(ctx18)
              val ctx19 = HookCtx(ctx18.props, ctx18.hook1, ctx18.hook2, ctx18.hook3, ctx18.hook4, ctx18.hook5, ctx18.hook6, ctx18.hook7, ctx18.hook8, ctx18.hook9, ctx18.hook10, ctx18.hook11, ctx18.hook12, ctx18.hook13, ctx18.hook14, ctx18.hook15, ctx18.hook16, ctx18.hook17, ctx18.hook18, h19)
              render(ctx19)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply18(f)
    }

  type AtStep19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19] = To[
    P,
    HookCtx.P19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19],
    HookCtxFn.P19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19]#Fn,
    DslMulti.AtStep19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19]#Next]

  implicit def atStep19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19]: AtStep19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19] =
    new StepMulti[P, HookCtx.P19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19], HookCtxFn.P19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19]#Fn] {
      override type Next[H20] = DslMulti.AtStep19[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19]#Next[H20]
      override def next[H20] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20]] =
            render => renderPrev { ctx19 =>
              val h20 = initNextHook(ctx19)
              val ctx20 = HookCtx(ctx19.props, ctx19.hook1, ctx19.hook2, ctx19.hook3, ctx19.hook4, ctx19.hook5, ctx19.hook6, ctx19.hook7, ctx19.hook8, ctx19.hook9, ctx19.hook10, ctx19.hook11, ctx19.hook12, ctx19.hook13, ctx19.hook14, ctx19.hook15, ctx19.hook16, ctx19.hook17, ctx19.hook18, ctx19.hook19, h20)
              render(ctx20)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply19(f)
    }

  type AtStep20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20] = To[
    P,
    HookCtx.P20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20],
    HookCtxFn.P20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20]#Fn,
    DslMulti.AtStep20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20]#Next]

  implicit def atStep20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20]: AtStep20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20] =
    new StepMulti[P, HookCtx.P20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20], HookCtxFn.P20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20]#Fn] {
      override type Next[H21] = DslMulti.AtStep20[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20]#Next[H21]
      override def next[H21] =
        (renderPrev, initNextHook) => {
          val renderNext: RenderFn[P, HookCtx.P21[P, H1, H2, H3, H4, H5, H6, H7, H8, H9, H10, H11, H12, H13, H14, H15, H16, H17, H18, H19, H20, H21]] =
            render => renderPrev { ctx20 =>
              val h21 = initNextHook(ctx20)
              val ctx21 = HookCtx(ctx20.props, ctx20.hook1, ctx20.hook2, ctx20.hook3, ctx20.hook4, ctx20.hook5, ctx20.hook6, ctx20.hook7, ctx20.hook8, ctx20.hook9, ctx20.hook10, ctx20.hook11, ctx20.hook12, ctx20.hook13, ctx20.hook14, ctx20.hook15, ctx20.hook16, ctx20.hook17, ctx20.hook18, ctx20.hook19, ctx20.hook20, h21)
              render(ctx21)
            }
          new DslMulti(renderNext)
        }
      override def squash[A] = f => _.apply20(f)
    }

}
